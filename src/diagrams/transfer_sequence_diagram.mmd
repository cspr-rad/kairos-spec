sequenceDiagram
    actor Bob as Bob :: User
    participant CasperWallet
    box l2-stack
    participant WebClient
    participant ApiServer
    participant Database
    participant Prover
    participant CasperNode
    end
    box on-chain
    participant VerifyDepositSession
    participant ValidiumContract
    end
    ApiServer ->>+ CasperNode: subscribe(DeployProcessed)
    Bob ->>+ WebClient: transfer(user: Bob :: User, user: Alice :: User, amount :: Money)

    Note over WebClient, ApiServer: This happens multiple times for different users, the ApiServer optimizes transfers
    WebClient ->>+ ApiServer: POST /transfer/<user: Bob :: User, user: Alice :: User, amount :: Money>
    ApiServer -->>- WebClient: Ok
    WebClient -->>- Bob: Ok

    Note over ApiServer, Prover: Once every x seconds, n transfers
    ApiServer ->>+ Prover: prove(transfer(Vector of (sender :: User, receiver :: User, amount :: Money)))
    Prover -->>- ApiServer: (new_account_balances :: AccountBalances, proof ::  Proof)
    %% what we create here is a deploy that will execute our transfer session,
    %% which verifies given the public inputs that the proof is valid. If validation
    %% is successfull we update the state using the proper contract entrypoint.
    %% Further down you will see how this will happen when once the contract gets
    %% executed on-chain
    ApiServer ->>+ ApiServer: create_verify_transfer_deploy(new_account_balances.root_hash() :: AccountBalanceStateHash, proof :: Proof, Vector of (sender :: User, receiver :: User, amount :: Money))
    ApiServer -->>- ApiServer: verify_transfer_deploy :: Deploy

    ApiServer ->>+ ApiServer: sign(verify_transfer_deploy: Deploy)
    ApiServer ->>- ApiServer: signed_verify_transfer_deploy :: SignedDeploy

    ApiServer ->>+ CasperNode: account_put_deploy(signed_verify_transfer_deploy :: SignedDeploy)
    CasperNode -->>- ApiServer: account_put_deploy_result

    Note Over CasperNode,VerifyTransferSession: Here the deploy gets executed on-chain
    CasperNode ->>+ VerifyTransferSession: call()
    Note Over VerifyTransferSession, ValidiumContract: This is where we verify the proof, we obviously need to provide the public inputs
    VerifyTransferSession ->>+ ValidiumContract: verify_entrypoint(new_account_balances.root_hash() :: AccountBalanceStateHash, proof ::  Proof, Vector of (sender :: User, receiver :: User, amount :: Money))
    ValidiumContract ->>+ ValidiumContract: if proof is Ok then update_state_entrypoint(new_account_balances.root_hash() :: AccountBalanceStateHash)
    ValidiumContract -->>- ValidiumContract: Ok
    ValidiumContract -->>- VerifyTransferSession: Ok 
    VerifyTransferSession -->>- CasperNode: end call()

    Note Over CasperNode, ApiServer: After the deploy gets processed we get notified
    CasperNode ->>+ ApiServer: DeployProcessed
    ApiServer ->>+ ApiServer: eventHandler(event :: DeployProcessed)
    ApiServer ->>+ Database: insert_transfers(Vector of (sender :: User, receiver :: User, amount :: Money))
    Database -->>- ApiServer: Ok
    ApiServer ->> WebClient: trigger_refresh
    ApiServer -->>- ApiServer: end eventHandler

    WebClient ->>+ ApiServer: GET /balance
    ApiServer ->>+ Database: get_balance(user: Bob :: User)
    Database -->>- ApiServer: balance :: Balance
    ApiServer -->>- WebClient: balance :: Balance
    WebClient ->> Bob: notify
    
    CasperNode -->>- ApiServer: ...
