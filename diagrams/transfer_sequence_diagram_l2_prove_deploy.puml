@startuml
autoactivate on
actor "Bob :: User" as Bob
box "L2-stack" #LightBlue
participant KairosCli
participant CasperCli
participant KairosNode
participant CasperCliBackend
participant Database
participant Prover
participant CasperNode
end box
box "on-chain" #LightGreen
participant TransferSession
participant KairosStateContract
end box

activate CasperNode
activate KairosNode

note over KairosNode, Prover
Once every x seconds or n transfers
end note
KairosNode -> Prover: prove(transfer(Vector<{sender, receiver, amount}>))
Prover --> KairosNode: (new_account_balances, proof)

note over KairosNode
What we create here is a "deploy" that will execute our transfer session on-chain.
The transfer session verifies that the proof is valid, given the public inputs.
If validation is successful, we update the state using the proper
contract entrypoint.
In the next diagram (Deploy Execution), you will see what happens
once the transfer session gets executed on-chain.
end note
KairosNode -> KairosNode: create_transfer_deploy(new_account_balances_root_hash, proof, Vector<{sender, receiver, amount}>)
KairosNode --> KairosNode: transfer_deploy :: Deploy

note over KairosNode, CasperCliBackend
This CasperCli is deployed together with the KairosNode on the backend server.
Don't confuse this CasperCli with the one in the deposit sequence diagram.
end note
KairosNode -> CasperCliBackend: sign_deploy(transfer_deploy, secret_key)
CasperCliBackend --> KairosNode: signed_transfer_deploy :: SignedDeploy

KairosNode -> CasperNode: account_put_deploy(signed_transfer_deploy)
CasperNode --> KairosNode: account_put_deploy_result
@enduml
